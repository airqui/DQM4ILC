
/// \file Testbeam.cc
/*
 *-------------------------------------------------------------
 * AHCALRawModule.cc source template automatically modified from 
 * CaloHitModule  generated by a class generator
 * by A. Irles, DESY, 23 March 2016
 *--------------------------------------------------------------
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "Testbeam.h"
// to handle and acces to the elements in the LCIO generic Object

// -- std headers
#include <ctime>
#include <time.h>
#include <time.h>
#include <locale>
#include <cstdlib>
#include <limits>
#include <string>

//#ifndef USELCIO
//#define USELCIO
#include "EVENT/LCGenericObject.h"
#include "EVENT/LCCollection.h"
#include "EVENT/LCEvent.h"
#include "EVENT/LCIO.h"
#include "UTIL/CellIDDecoder.h"
#include "UTIL/LCTOOLS.h"
//#endif

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMCoreTool.h"
#include "dqm4hep/DQMRun.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMEvent.h"
#include "dqm4hep/DQMQualityTest.h"
#include "dqm4hep/DQMModuleApi.h"
#include "dqm4hep/DQMPlugin.h"

// -- root headers
#include "TRandom.h"
#include "TString.h" // Added by Tom for TString handling
#include "TDatime.h"

//using namespace lcio;

namespace dqm4hep
{
  // module plugin declaration
  DQM_PLUGIN_DECL( Testbeam , "Testbeam" )

  //-------------------------------------------------------------------------------------------------

  Testbeam::Testbeam() :
  DQMAnalysisModule()
  {
    setDetectorName("NO DETECTOR");
    setVersion(1, 0, 0);
  }

  //-------------------------------------------------------------------------------------------------

  Testbeam::~Testbeam()
  {
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode Testbeam::readSettings(const TiXmlHandle xmlHandle)
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- readSettings()" );


    //---------------------------------------------------------------------
    // chips and channels to scan
    m_ChipIDLayer1 = 0;
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, 
                            DQMXmlHelper::readParameterValue(xmlHandle, "ChipIDLayer1", m_ChipIDLayer1));
    m_ChipIDLayer2 = 0;
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, 
                            DQMXmlHelper::readParameterValue(xmlHandle, "ChipIDLayer2", m_ChipIDLayer2));
    m_ChipIDLayer3 = 0;
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, 
                            DQMXmlHelper::readParameterValue(xmlHandle, "ChipIDLayer3", m_ChipIDLayer3));

    // Reading in our channel numers from the XML file
    m_ChannelNum1 = 0;
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, 
                            DQMXmlHelper::readParameterValue(xmlHandle,"ChannelNum1", m_ChannelNum1));
    m_ChannelNum2 = 0;
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, 
                            DQMXmlHelper::readParameterValue(xmlHandle, "ChannelNum2", m_ChannelNum2));
    m_ChannelNum3 = 0;
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, 
                            DQMXmlHelper::readParameterValue(xmlHandle, "ChannelNum3", m_ChannelNum3));
    m_ChannelNum4 = 0;
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, 
                            DQMXmlHelper::readParameterValue(xmlHandle, "ChannelNum4", m_ChannelNum4));
  
    //---------------------------------------------------------------------
    //ADC hitmaps
    m_pADC_300 = NULL;
    m_pADC_500 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_300", m_pADC_300));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_500", m_pADC_500));

    //-----------------------------------------------------
    // Layer1 channels, ADC & TDC
    // chan_1
    m_pADC_Layer1_1 = NULL;
    m_pTDC_Layer1_1 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_Layer1_1", m_pADC_Layer1_1));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TDC_Layer1_1", m_pTDC_Layer1_1));
    // chan_2
    m_pADC_Layer1_2 = NULL;
    m_pTDC_Layer1_2 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_Layer1_2", m_pADC_Layer1_2));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TDC_Layer1_2", m_pTDC_Layer1_2));
    // chan_3
    m_pADC_Layer1_3 = NULL;
    m_pTDC_Layer1_3 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_Layer1_3", m_pADC_Layer1_3));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TDC_Layer1_3", m_pTDC_Layer1_3));
    // chan_4
    m_pADC_Layer1_4 = NULL;
    m_pTDC_Layer1_4 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_Layer1_4", m_pADC_Layer1_4));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TDC_Layer1_4", m_pTDC_Layer1_4));

    //-----------------------------------------------------
    // Layer2 channels, ADC & TDC
    // chan_1
    m_pADC_Layer2_1 = NULL;
    m_pTDC_Layer2_1 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_Layer2_1", m_pADC_Layer2_1));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TDC_Layer2_1", m_pTDC_Layer2_1));
    // chan_2
    m_pADC_Layer2_2 = NULL;
    m_pTDC_Layer2_2 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_Layer2_2", m_pADC_Layer2_2));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TDC_Layer2_2", m_pTDC_Layer2_2));
    // chan_3
    m_pADC_Layer2_3 = NULL;
    m_pTDC_Layer2_3 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_Layer2_3", m_pADC_Layer2_3));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TDC_Layer2_3", m_pTDC_Layer2_3));
    // chan_4
    m_pADC_Layer2_4 = NULL;
    m_pTDC_Layer2_4 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_Layer2_4", m_pADC_Layer2_4));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TDC_Layer2_4", m_pTDC_Layer2_4));

    //-----------------------------------------------------
    // Layer3 channels, ADC & TDC
    // chan_1
    m_pADC_Layer3_1 = NULL;
    m_pTDC_Layer3_1 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_Layer3_1", m_pADC_Layer3_1));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TDC_Layer3_1", m_pTDC_Layer3_1));
    // chan_2
    m_pADC_Layer3_2 = NULL;
    m_pTDC_Layer3_2 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_Layer3_2", m_pADC_Layer3_2));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TDC_Layer3_2", m_pTDC_Layer3_2));
    // chan_3
    m_pADC_Layer3_3 = NULL;
    m_pTDC_Layer3_3 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_Layer3_3", m_pADC_Layer3_3));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TDC_Layer3_3", m_pTDC_Layer3_3));
    // chan_4
    m_pADC_Layer3_4 = NULL;
    m_pTDC_Layer3_4 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_Layer3_4", m_pADC_Layer3_4));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TDC_Layer3_4", m_pTDC_Layer3_4));


    // TEMPERATURE
    m_pTempAverage_1 = NULL;
    m_pTempAverage_2 = NULL;
    m_pTempAverage_3 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TempAverage_1", m_pTempAverage_1));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TempAverage_2", m_pTempAverage_2));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TempAverage_3", m_pTempAverage_3));
    m_pTempDIF_1 = NULL;
    m_pTempDIF_2 = NULL;
    m_pTempDIF_3 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TempDIF_1", m_pTempDIF_1));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TempDIF_2", m_pTempDIF_2));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TempDIF_3", m_pTempDIF_3));
    m_pTempPWR_1 = NULL;
    m_pTempPWR_2 = NULL;
    m_pTempPWR_3 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TempPWR_1", m_pTempPWR_1));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TempPWR_2", m_pTempPWR_2));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TempPWR_3", m_pTempPWR_3));

    //-----------------------------------------------------
    m_dumpEvent = false;
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "DumpEvent", m_dumpEvent));

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode Testbeam::initModule()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- init()" );

    // print directory structure of monitor element storage in console
    DQMModuleApi::cd(this);
    DQMModuleApi::ls(this, true);

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode Testbeam::endModule()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- end()" );
    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode Testbeam::processEvent(DQMEvent *pEvent)
  {

    int CycleNrIndex = 0;
    int BxIDIndex = 1;
    int EvtNrIndex = 2;
    int ChipIDIndex = 3;
    int NChannelsIndex = 4;
    int TDCFirstChannelIndex = 5;
    int ADCFirstChannelIndex = TDCFirstChannelIndex+36;


    EVENT::LCEvent *pLCEvent = pEvent->getEvent<EVENT::LCEvent>();

    if(!pLCEvent)
      return STATUS_CODE_FAILURE;

    if(m_dumpEvent)
      UTIL::LCTOOLS::dumpEvent(pLCEvent);


    const std::vector<std::string> *pCollectionNames = pLCEvent->getCollectionNames();

    time_t ts =0;
    int timestamp;
    float tdif_1, tdif_2, tdif_3;
    float tpwr_1, tpwr_2, tpwr_3;
    float tav_1, tav_2, tav_3;

    for(std::vector<std::string>::const_iterator colIter = pCollectionNames->begin();
	colIter != pCollectionNames->end() ; ++colIter)
      {

	const std::string &collectionName(*colIter);

	EVENT::LCCollection *pLCCollection = pLCEvent->getCollection(collectionName);


	//----------------------------------
	// temperature section
	if(collectionName=="TempSensor")
	  {

	    const int nElements = pLCCollection->getNumberOfElements();
	    if(nElements !=3) continue;

	    std::string timestamp = pLCCollection->getParameters().getStringVal("Timestamp");
	    struct tm tm;
	    strptime(timestamp.c_str(), "%a, %d %b %Y %H:%M:%S %z", &tm);
	    time_t epoch;
	    epoch = mktime(&tm);
	    
	    //  dt_start = TDatime(timestamp);

	    for(int e=0 ; e<nElements ; e++)
	      {
	    const EVENT::LCGenericObject *const pTempRaw = 
	      dynamic_cast<const EVENT::LCGenericObject *const>(pLCCollection->getElementAt(e));
		
		if(NULL == pTempRaw)
		  continue;
		
		if(e==0) {tdif_1 = pTempRaw->getIntVal(8); tpwr_1 = pTempRaw->getIntVal(9);}
		if(e==1) {tdif_2 = pTempRaw->getIntVal(8); tpwr_2 = pTempRaw->getIntVal(9);}
		if(e==2) {tdif_3 = pTempRaw->getIntVal(8); tpwr_3 = pTempRaw->getIntVal(9);}

		int ntemps=0, tempav=0;
		for(int i=0; i<6; i++) { 
		  if(pTempRaw->getIntVal(2+i) < 1000) {ntemps++; tempav+=pTempRaw->getIntVal(2+i);}  
		}
		tempav=tempav/ntemps;
		if(e==0) tav_1=tempav/10.;
		if(e==1) tav_2=tempav/10.;
		if(e==2) tav_3=tempav/10.;
	      }

	    Int_t pointID = m_pTempAverage_1->get<TGraph>()->GetN();
	    m_pTempAverage_1->get<TGraph>()->SetPoint(pointID, int(epoch), tav_1 );
	    pointID = m_pTempAverage_2->get<TGraph>()->GetN();
	    m_pTempAverage_2->get<TGraph>()->SetPoint(pointID, int(epoch), tav_2 );
	    pointID = m_pTempAverage_3->get<TGraph>()->GetN();
	    m_pTempAverage_3->get<TGraph>()->SetPoint(pointID, int(epoch), tav_3 );

	    pointID = m_pTempDIF_1->get<TGraph>()->GetN();
	    m_pTempDIF_1->get<TGraph>()->SetPoint(pointID, int(epoch), tdif_1 );
	    pointID = m_pTempDIF_2->get<TGraph>()->GetN();
	    m_pTempDIF_2->get<TGraph>()->SetPoint(pointID, int(epoch), tdif_2 );
	    pointID = m_pTempDIF_3->get<TGraph>()->GetN();
	    m_pTempDIF_3->get<TGraph>()->SetPoint(pointID, int(epoch), tdif_3 );

	    pointID = m_pTempPWR_1->get<TGraph>()->GetN();
	    m_pTempPWR_1->get<TGraph>()->SetPoint(pointID, int(epoch), tpwr_1 );
	    pointID = m_pTempPWR_2->get<TGraph>()->GetN();
	    m_pTempPWR_2->get<TGraph>()->SetPoint(pointID, int(epoch), tpwr_2 );
	     pointID = m_pTempPWR_3->get<TGraph>()->GetN();
	    m_pTempPWR_3->get<TGraph>()->SetPoint(pointID, int(epoch), tpwr_3 );

	  }

	//----------------------------------
	// BIF section
	if(collectionName=="EUDAQDataBIF")
	  {
	    
	    // const int nElements = pLCCollection->getNumberOfElements();
	    // for(int e=0 ; e<nElements ; e++)
	    //   {
	    // 	const EVENT::LCGenericObject *const pBIFRaw = 
	    // 	  dynamic_cast<const EVENT::LCGenericObject *const>(pLCCollection->getElementAt(e));
		
	    // 	if(NULL == pBIFRaw)
	    // 	  continue;
		
	    // 	timestamp = pBIFRaw->getIntVal(2);

	    //   }

	  }

	//----------------------------------
	// AHCAL section
	if(collectionName=="EUDAQDataScCAL")
	  {

	    if(pLCCollection->getTypeName() == EVENT::LCIO::LCGENERICOBJECT)
	      {

		const int nElements = pLCCollection->getNumberOfElements();
		for(int e=0 ; e<nElements ; e++)
		  {
		    const EVENT::LCGenericObject *const pAHCALRaw = 
		      dynamic_cast<const EVENT::LCGenericObject *const>(pLCCollection->getElementAt(e));

		    if(NULL == pAHCALRaw)
		      continue;

		    const int nChannels = pAHCALRaw->getIntVal(NChannelsIndex);
		    if(nChannels!= 36) {
		      LOG4CXX_INFO( dqmMainLogger , "Wrong number of channels ("<<nChannels<<"), skip event" ); 
		      continue;
		    }

		    for(int f=0 ; f<nChannels ; f++)		// This loop iterates over the channels in each readout cycle
		      {

			// Vectors for storing our TDC and ADC by channel

			int tdcRAW;
			int adcRAW;
			int tdc;
			int adc;
			int hitbit_tdc;
			int gainbit_tdc;
			int hitbit_adc;
			int gainbit_adc;

			tdcRAW = pAHCALRaw->getIntVal(TDCFirstChannelIndex+f);
			adcRAW = pAHCALRaw->getIntVal(ADCFirstChannelIndex+f);

			tdc = tdcRAW%4096;
			adc = adcRAW%4096;

			hitbit_adc = (adcRAW & 0x1000)?1:0;
			gainbit_adc = (adcRAW & 0x2000)?1:0;

			hitbit_tdc = (tdcRAW & 0x1000)?1:0;
			gainbit_tdc = (tdcRAW & 0x2000)?1:0;

			//	std::cout<<m_ChipIDLayer1<<" "<< m_ChipIDLayer2<<" "<<m_ChipIDLayer3<<" "<<m_ChannelNum1<<" "<<m_ChannelNum2<<" "<<m_ChannelNum3<<" "<<m_ChannelNum4<<std::endl;

			if( hitbit_adc != hitbit_tdc || pAHCALRaw->getIntVal(EvtNrIndex) ==0 ) continue;

			if(hitbit_adc != 1) continue;

			bool Ch_1=false, Ch_2=false, Ch_3=false, Ch_4=false; 
                        if(f == m_ChannelNum1 ) Ch_1=true;
                        if(f == m_ChannelNum2 ) Ch_2=true;
                        if(f == m_ChannelNum3 ) Ch_3=true;
                        if(f == m_ChannelNum4 ) Ch_4=true;

			//----- Layer1
			//------------------------
			if(pAHCALRaw->getIntVal(ChipIDIndex) == m_ChipIDLayer1) {
			  if(Ch_1) {
			    //			    std::cout<<"Channel "<<m_ChipIDLayer1<<" on Layer 1, with adc = "<<adc<<std::endl;
                            m_pADC_Layer1_1->get<TH1I>()->Fill(adc);
                            m_pTDC_Layer1_1->get<TH1I>()->Fill(tdc);
                          }
			if(Ch_2) {
                            m_pADC_Layer1_2->get<TH1I>()->Fill(adc);
                            m_pTDC_Layer1_2->get<TH1I>()->Fill(tdc);
                          }
			if(Ch_3) {
                            m_pADC_Layer1_3->get<TH1I>()->Fill(adc);
                            m_pTDC_Layer1_3->get<TH1I>()->Fill(tdc);
                          }
			if(Ch_4) {
                            m_pADC_Layer1_4->get<TH1I>()->Fill(adc);
                            m_pTDC_Layer1_4->get<TH1I>()->Fill(tdc);
                          }
			}

			//----- Layer2
			//------------------------
			if(pAHCALRaw->getIntVal(ChipIDIndex) == m_ChipIDLayer2) {
			  if(Ch_1) {
                            m_pADC_Layer2_1->get<TH1I>()->Fill(adc);
                            m_pTDC_Layer2_1->get<TH1I>()->Fill(tdc);
                          }
			if(Ch_2) {
                            m_pADC_Layer2_2->get<TH1I>()->Fill(adc);
                            m_pTDC_Layer2_2->get<TH1I>()->Fill(tdc);
                          }
			if(Ch_3) {
                            m_pADC_Layer2_3->get<TH1I>()->Fill(adc);
                            m_pTDC_Layer2_3->get<TH1I>()->Fill(tdc);
                          }
			if(Ch_4) {
                            m_pADC_Layer2_4->get<TH1I>()->Fill(adc);
                            m_pTDC_Layer2_4->get<TH1I>()->Fill(tdc);
                          }
			}
			
			//----- Layer3
			//------------------------
			if(pAHCALRaw->getIntVal(ChipIDIndex) == m_ChipIDLayer3) {
			  if(Ch_1) {
                            m_pADC_Layer3_1->get<TH1I>()->Fill(adc);
                            m_pTDC_Layer3_1->get<TH1I>()->Fill(tdc);
                          }
			if(Ch_2) {
                            m_pADC_Layer3_2->get<TH1I>()->Fill(adc);
                            m_pTDC_Layer3_2->get<TH1I>()->Fill(tdc);
                          }
			if(Ch_3) {
                            m_pADC_Layer3_3->get<TH1I>()->Fill(adc);
                            m_pTDC_Layer3_3->get<TH1I>()->Fill(tdc);
                          }
			if(Ch_4) {
                            m_pADC_Layer3_4->get<TH1I>()->Fill(adc);
                            m_pTDC_Layer3_4->get<TH1I>()->Fill(tdc);
                          }
			}

			//--------------------------
			//--- ADC hitmaps
			if( adc>300 ) m_pADC_300->get<TH2I>()->Fill(f,pAHCALRaw->getIntVal(ChipIDIndex));
			if( adc>500 ) m_pADC_500->get<TH2I>()->Fill(f,pAHCALRaw->getIntVal(ChipIDIndex));

		      }//for f

		  }//for elements

	      }// if LCGENERICOBJECT

	  }//if collectionName == EUDAQDataScCAL
      }// iterator


    return STATUS_CODE_SUCCESS;

  }

  //-------------------------------------------------------------------------------------------------

  StatusCode Testbeam::startOfCycle()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- startOfCycle()" );
    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode Testbeam::endOfCycle()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- endOfCycle()" );

    // run all quality tests on all monitor elements
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMModuleApi::runQualityTests(this));

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode Testbeam::startOfRun(DQMRun *pRun)
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- startOfRun()" );
    LOG4CXX_INFO( dqmMainLogger , "Run no " << pRun->getRunNumber() );
    //	time_t startTime = pRun->getStartTime();
    time_t startTime = std::chrono::system_clock::to_time_t(pRun->getStartTime());

    std::string timeStr;
    DQMCoreTool::timeToHMS(startTime, timeStr);

    LOG4CXX_INFO( dqmMainLogger , "Start time " << timeStr );
    LOG4CXX_INFO( dqmMainLogger , "Detector is " << pRun->getDetectorName() );
    LOG4CXX_INFO( dqmMainLogger , "Description " << pRun->getDescription() );

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode Testbeam::endOfRun(DQMRun *pRun)
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- endOfRun()" );
    LOG4CXX_INFO( dqmMainLogger , "Run no " << pRun->getRunNumber() );

    //	time_t endTime = pRun->getEndTime();
    time_t endTime = std::chrono::system_clock::to_time_t(pRun->getEndTime());
    std::string timeStr;
    DQMCoreTool::timeToHMS(endTime, timeStr);

    LOG4CXX_INFO( dqmMainLogger , "End time " << timeStr );

    return STATUS_CODE_SUCCESS;
  }

};

