/// \file AHCALRawModuleGlobal.cc
/*
 *-------------------------------------------------------------
 * AHCALRawModule.cc source template automatically modified from 
 * CaloHitModule  generated by a class generator
 * by A. Irles, DESY, 23 March 2016
 *--------------------------------------------------------------
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "AHCALRawModuleGlobal.h"
// to handle and acces to the elements in the LCIO generic Object

// -- std headers
#include <ctime>
#include <cstdlib>
#include <limits>

//#ifndef USELCIO
//#define USELCIO
#include "EVENT/LCGenericObject.h"
#include "EVENT/LCCollection.h"
#include "EVENT/LCEvent.h"
#include "EVENT/LCIO.h"
#include "UTIL/CellIDDecoder.h"
#include "UTIL/LCTOOLS.h"
//#endif

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMCoreTool.h"
#include "dqm4hep/DQMRun.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMEvent.h"
#include "dqm4hep/DQMQualityTest.h"
#include "dqm4hep/DQMModuleApi.h"
#include "dqm4hep/DQMPlugin.h"

// -- root headers
#include "TRandom.h"
#include "TString.h" // Added by Tom for TString handling


//using namespace lcio;

namespace dqm4hep
{
  // module plugin declaration
  DQM_PLUGIN_DECL( AHCALRawModuleGlobal , "AHCALRawModuleGlobal" )

  //-------------------------------------------------------------------------------------------------

  AHCALRawModuleGlobal::AHCALRawModuleGlobal() :
  DQMAnalysisModule()
  {
    setDetectorName("NO DETECTOR");
    setVersion(1, 0, 0);
  }

  //-------------------------------------------------------------------------------------------------

  AHCALRawModuleGlobal::~AHCALRawModuleGlobal()
  {
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode AHCALRawModuleGlobal::readSettings(const TiXmlHandle xmlHandle)
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- readSettings()" );

    //m_pNHitElement = NULL;

    //---------------------------------------------------------------------

    CycleNrIndex = 0;
    BxIDIndex = 0;
    EvtNrIndex = 0;
    ChipIDIndex = 0;
    NChannelsIndex = 0;
    TDCFirstChannelIndex = 0;
    ADCFirstChannelIndex = 0;

    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "CycleNrIndex", CycleNrIndex));
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "BxIDIndex", BxIDIndex));
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "EvtNrIndex", EvtNrIndex));
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle, 
													     "NChannelsIndex", NChannelsIndex));
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "TDCFirstChannelIndex", TDCFirstChannelIndex));
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "ADCFirstChannelIndex", ADCFirstChannelIndex));

    if(BxIDIndex = 0 || EvtNrIndex == 0 || ChipIDIndex == 0 || NChannelsIndex == 0 || TDCFirstChannelIndex == 0 ||  ADCFirstChannelIndex == 0) LOG4CXX_ERROR( dqmMainLogger , "LCGenericObject indices were read successfuly but were invalid - this may be a problem with your steering file");

    //---------------------------------------------------------------------

    LDAIndex = 0;
    portIndex = 0;
    T1Index = 0;
    T2Index = 0;
    T3Index = 0;
    T4Index = 0;
    T5Index = 0;
    T6Index = 0;
    TDIFIndex = 0;
    TPWRIndex = 0;
    
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "LDAIndex", LDAIndex));
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "portIndex", portIndex));
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "T1Index", T1Index));
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "T2Index", T2Index));
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "T3Index", T3Index));
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "T4Index", T4Index));
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "T5Index", T5Index));
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "T6Index", T6Index));
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "TDIFIndex", TDIFIndex));
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "TPWRIndex", TPWRIndex));

    //---------------------------------------------------------------------
    //channel 1
    m_pADC_300 = NULL;
    m_pADC_500 = NULL;
    m_pADC_1000 = NULL;
    m_pADC_1500 = NULL;

    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_300", m_pADC_300));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_500", m_pADC_500));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_1000", m_pADC_1000));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ADC_1500", m_pADC_1500));

    m_pWrongHB = NULL;
    m_pWrongGB = NULL;
    m_pWrongBits = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "WrongHB", m_pWrongHB));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "WrongGB", m_pWrongGB));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "WrongBits", m_pWrongBits));

    // m_pADC_500->get<TH2I>->

    //-----------------------------------------------------
    m_dumpEvent = false;
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "DumpEvent", m_dumpEvent));

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode AHCALRawModuleGlobal::initModule()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- init()" );

    // print directory structure of monitor element storage in console
    DQMModuleApi::cd(this);
    DQMModuleApi::ls(this, true);

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode AHCALRawModuleGlobal::endModule()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- end()" );
    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode AHCALRawModuleGlobal::processEvent(DQMEvent *pEvent)
  {

    //int CycleNrIndex = 0;
    //int BxIDIndex = 1;
    //int EvtNrIndex = 2;
    //int ChipIDIndex = 3;
    //int NChannelsIndex = 4;
    //int TDCFirstChannelIndex = 5;
    //int ADCFirstChannelIndex = TDCFirstChannelIndex+36;

    int EventCntIndex = 1;
    int BxIDIndex = 1;
    int EvtNrIndex = 2;
    int ChipIDIndex = 3;
    int NChannelsIndex = 4;
    int TDCFirstChannelIndex = 5;
    int ADCFirstChannelIndex = TDCFirstChannelIndex+36;

    EVENT::LCEvent *pLCEvent = pEvent->getEvent<EVENT::LCEvent>();

    if(!pLCEvent)
      return STATUS_CODE_FAILURE;

    if(m_dumpEvent)
      UTIL::LCTOOLS::dumpEvent(pLCEvent);

    int totalNB = 0;
    int totalNHB = 0, totalNGB = 0;
    int NB_1 = 0, NB_2 = 0, NB_3 = 0, NB_4 = 0, NB_5 = 0 ;

    const std::vector<std::string> *pCollectionNames = pLCEvent->getCollectionNames();

    for(std::vector<std::string>::const_iterator colIter = pCollectionNames->begin();
	colIter != pCollectionNames->end() ; ++colIter)
      {

	const std::string &collectionName(*colIter);

	EVENT::LCCollection *pLCCollection = pLCEvent->getCollection(collectionName);

	if(collectionName=="TempSensor")
	  {

	    

	  }

	if(collectionName=="EUDAQDataScCAL")
	  {

	    if(pLCCollection->getTypeName() == EVENT::LCIO::LCGENERICOBJECT)
	      {

		const int nElements = pLCCollection->getNumberOfElements();
		for(int e=0 ; e<nElements ; e++)
		  {
		    const EVENT::LCGenericObject *const pAHCALRaw = 
		      dynamic_cast<const EVENT::LCGenericObject *const>(pLCCollection->getElementAt(e));

		    if(NULL == pAHCALRaw)
		      continue;

		    const int nChannels = pAHCALRaw->getIntVal(NChannelsIndex);
		    if(nChannels!= 36) {
		      LOG4CXX_INFO( dqmMainLogger , "Wrong number of channels ("<<nChannels<<"), skip event" ); 
		      continue;
		    }

		    for(int f=0 ; f<nChannels ; f++)		// This loop iterates over the channels in each readout cycle
		      {


			// Vectors for storing our TDC and ADC by channel

			int tdcRAW;
			int adcRAW;
			int tdc;
			int adc;
			int hitbit_tdc;
			int gainbit_tdc;
			int hitbit_adc;
			int gainbit_adc;

			tdcRAW = pAHCALRaw->getIntVal(TDCFirstChannelIndex+f);
			adcRAW = pAHCALRaw->getIntVal(ADCFirstChannelIndex+f);

			tdc = tdcRAW%4096;
			adc = adcRAW%4096;

			hitbit_adc = (adcRAW & 0x1000)?1:0;
			gainbit_adc = (adcRAW & 0x2000)?1:0;

			hitbit_tdc = (tdcRAW & 0x1000)?1:0;
			gainbit_tdc = (tdcRAW & 0x2000)?1:0;

			//std::vector<int> tdcRAW(nChannels);
			//std::vector<int> adcRAW(nChannels);

			//std::vector<int> tdc(nChannels);
			//std::vector<int> adc(nChannels);

			//std::vector<int> hitbit_tdc(nChannels);
			//std::vector<int> gainbit_tdc(nChannels);

			//std::vector<int> hitbit_adc(nChannels);
			//std::vector<int> gainbit_adc(nChannels);

			//tdcRAW[f] = pAHCALRaw->getIntVal(TDCFirstChannelIndex+f);
			//adcRAW[f] = pAHCALRaw->getIntVal(ADCFirstChannelIndex+f);

			//tdc[f] = tdcRAW[f]%4096;
			//adc[f] = adcRAW[f]%4096;

			//hitbit_adc[f] = (adcRAW[f] & 0x1000)?1:0;//(adcRAW[f] / 4096) % 2;//(adcRAW[f]& 0x1000)/4096;
			//gainbit_adc[f] = (adcRAW[f] & 0x2000)?1:0;////adcRAW[f] / 8192;//(adcRAW[f]& 0x2000)/8192;

			//hitbit_tdc[f] = (tdcRAW[f] & 0x1000)?1:0;
			//gainbit_tdc[f] = (tdcRAW[f] & 0x2000)?1:0;

			if(hitbit_adc==1 && hitbit_tdc==1 && adc>300 ) m_pADC_300->get<TH2I>()->Fill(f,pAHCALRaw->getIntVal(ChipIDIndex));
			if(hitbit_adc==1 && hitbit_tdc==1 && adc>500 ) m_pADC_500->get<TH2I>()->Fill(f,pAHCALRaw->getIntVal(ChipIDIndex));
			if(hitbit_adc==1 && hitbit_tdc==1 && adc>1000 ) m_pADC_1000->get<TH2I>()->Fill(f,pAHCALRaw->getIntVal(ChipIDIndex));
			if(hitbit_adc==1 && hitbit_tdc==1 && adc>1500 ) m_pADC_1500->get<TH2I>()->Fill(f,pAHCALRaw->getIntVal(ChipIDIndex));

			totalNB++;
			if( (gainbit_tdc != gainbit_adc) && hitbit_adc==1  ) {
			  NB_1++;
			  m_pWrongBits->get<TGraph>()->SetPoint(1, 1 , NB_1/totalNB);
			}
			if( (hitbit_tdc != hitbit_adc) && (gainbit_tdc != gainbit_adc) && hitbit_adc==1  )  {
			  NB_2++;
			}
			if( (hitbit_tdc != hitbit_adc) && hitbit_adc==0 ) {
			  NB_3++;
			}
			if( (gainbit_tdc != gainbit_adc) && hitbit_adc==0  ) {
			  NB_4++;
			}
			if( (hitbit_tdc != hitbit_adc) && (gainbit_tdc != gainbit_adc) && hitbit_adc==0  ) {
			  NB_5++;
			}

			if(hitbit_adc==1 && hitbit_tdc==0 && adc>0 ) {
			  totalNHB++;
			  m_pWrongHB->get<TH2I>()->Fill(f,pAHCALRaw->getIntVal(ChipIDIndex));//SetBinContent(f,pAHCALRaw->getIntVal(ChipIDIndex),totalNHB/totalNB);
			}
			if(hitbit_adc==1 && (gainbit_tdc!=gainbit_adc) && adc>0 ) {
			  totalNGB++;
			  m_pWrongGB->get<TH2I>()->Fill(f,pAHCALRaw->getIntVal(ChipIDIndex));//->SetBinContent(f,pAHCALRaw->getIntVal(ChipIDIndex),totalNGB/totalNB);
			}

		      }//for f

		  }//for elements

	      }// if LCGENERICOBJECT

	  }//if collectionName == EUDAQDataScCAL
      }// iterator


    return STATUS_CODE_SUCCESS;

  }

  //-------------------------------------------------------------------------------------------------

  StatusCode AHCALRawModuleGlobal::startOfCycle()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- startOfCycle()" );
    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode AHCALRawModuleGlobal::endOfCycle()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- endOfCycle()" );

    // run all quality tests on all monitor elements
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMModuleApi::runQualityTests(this));

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode AHCALRawModuleGlobal::startOfRun(DQMRun *pRun)
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- startOfRun()" );
    LOG4CXX_INFO( dqmMainLogger , "Run no " << pRun->getRunNumber() );
    //	time_t startTime = pRun->getStartTime();
    time_t startTime = std::chrono::system_clock::to_time_t(pRun->getStartTime());

    std::string timeStr;
    DQMCoreTool::timeToHMS(startTime, timeStr);

    LOG4CXX_INFO( dqmMainLogger , "Start time " << timeStr );
    LOG4CXX_INFO( dqmMainLogger , "Detector is " << pRun->getDetectorName() );
    LOG4CXX_INFO( dqmMainLogger , "Description " << pRun->getDescription() );

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode AHCALRawModuleGlobal::endOfRun(DQMRun *pRun)
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- endOfRun()" );
    LOG4CXX_INFO( dqmMainLogger , "Run no " << pRun->getRunNumber() );

    //	time_t endTime = pRun->getEndTime();
    time_t endTime = std::chrono::system_clock::to_time_t(pRun->getEndTime());
    std::string timeStr;
    DQMCoreTool::timeToHMS(endTime, timeStr);

    LOG4CXX_INFO( dqmMainLogger , "End time " << timeStr );

    return STATUS_CODE_SUCCESS;
  }

};

