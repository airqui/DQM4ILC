  /// \file DQMDataSourceProcessor.cc
/*
 *
 * DQMDataSourceProcessor.cc source template automatically generated by a class generator
 * Creation date : jeu. avr. 14 2016
 *
 * This file is part of DQM4ILC libraries.
 * 
 * DQM4ILC is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4ILC is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4ILC.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4ilc headers
#include "dqm4ilc/DQMDataSourceProcessor.h"

// -- dqm4hep headers
#include "dqm4hep/DQMRun.h"
#include "dqm4hep/DQMDimRunControlClient.h"
#include "dqm4hep/DQMDimEventClient.h"
#include "dqm4hep/DQMCoreTool.h"
#include "dqm4hep/DQMLogging.h"

// -- marlin headers
#include "marlin/ProcessorMgr.h"

// -- lcio headers
#include "IMPL/LCRunHeaderImpl.h"
#include "IMPL/LCEventImpl.h"

namespace dqm4ilc
{

DQMDataSourceProcessor aDqmDataSourceProcessor;

//-------------------------------------------------------------------------------------------------

DQMDataSourceProcessor::DQMDataSourceProcessor() :
		marlin::DataSourceProcessor("DQMDataSourceProcessor")
{
    registerProcessorParameter("FollowRunControl",
                            "Whether the processor chain has to wait for a start of run signal",
							m_followRunControl,
							true);

    registerProcessorParameter("EventCollectorName",
                            "The event collector name to connect to",
							m_eventCollectorName,
							std::string("DEFAULT"));

    registerProcessorParameter("RunControlName",
                            "The run control name to connect to",
							m_runControlName,
							std::string("DEFAULT"));

    registerProcessorParameter("EventQueryTimeout",
                            "The event query timeout",
							m_eventQueryTimeout,
							static_cast<int>(2) ); // 2 seconds
}

//-------------------------------------------------------------------------------------------------

void DQMDataSourceProcessor::init()
{
    m_pEventClient = new dqm4hep::DQMDimEventClient();
    m_pLCEventStreamer = new dqm4ilc::DQMLCEventStreamer();

    m_pEventClient->setEventStreamer(m_pLCEventStreamer);
    m_pEventClient->setCollectorName(m_eventCollectorName);

    if( m_followRunControl )
    {
    	m_pRunControlClient = new dqm4hep::DQMDimRunControlClient();
    	m_pRunControlClient->setRunControlName(m_runControlName);

    	THROW_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, m_pRunControlClient->connectToService() );
    }
}

//-------------------------------------------------------------------------------------------------

void DQMDataSourceProcessor::end()
{
    delete m_pEventClient;
    delete m_pLCEventStreamer;

    if( m_followRunControl )
    	delete m_pRunControlClient;
}

//-------------------------------------------------------------------------------------------------

void DQMDataSourceProcessor::readDataSource( int numEvents )
{
	int currentRunNumber = 0;
	int nProcessedEvents = 0;

	while(1)
	{
		if(m_followRunControl)
		{
			bool firstCall = true;

			while( ! m_pRunControlClient->isRunning() )
			{
				if( firstCall )
				{
					streamlog_out(MESSAGE) << "... Waiting for new run ...";
					firstCall = false;
				}

				dqm4hep::DQMCoreTool::sleep( std::chrono::milliseconds(10) );
			}

			int runNumber = m_pRunControlClient->getCurrentRun()->getRunNumber();

			if(runNumber != currentRunNumber)
			{
				currentRunNumber = runNumber;
				std::string description = m_pRunControlClient->getCurrentRun()->getDescription();
				std::string detectorName = m_pRunControlClient->getCurrentRun()->getDetectorName();
				const dqm4hep::DQMTimePoint &startTime = m_pRunControlClient->getCurrentRun()->getStartTime();

				// create, convert and process run header
				IMPL::LCRunHeaderImpl *pLCRunHeader = new IMPL::LCRunHeaderImpl();

				pLCRunHeader->setRunNumber(currentRunNumber);
				pLCRunHeader->setDetectorName(detectorName);
				pLCRunHeader->setDescription(description);
				pLCRunHeader->parameters().setValue("START_TIME", static_cast<int>(std::chrono::system_clock::to_time_t(startTime)));

				marlin::ProcessorMgr::instance()->processRunHeader(pLCRunHeader);

				delete pLCRunHeader;
			}
		}

		dqm4hep::DQMEvent *pEvent = NULL;
		dqm4hep::StatusCode statusCode = m_pEventClient->queryEvent( pEvent , m_eventQueryTimeout );

		if( ! pEvent )
			continue;

		if( statusCode != dqm4hep::STATUS_CODE_SUCCESS )
		{
			delete pEvent;
			dqm4hep::DQMCoreTool::sleep( std::chrono::milliseconds(10) );
			continue;
		}

		EVENT::LCEvent *pLCEvent = pEvent->getEvent<EVENT::LCEvent>();

		if( ! pLCEvent )
		{
			delete pEvent;
			dqm4hep::DQMCoreTool::sleep( std::chrono::milliseconds(10) );
			continue;
		}

		marlin::ProcessorMgr::instance()->processEvent(pLCEvent);

		// also deletes pLCEvent internally
		delete pEvent;

		nProcessedEvents ++;

		if(numEvents != 0 && nProcessedEvents >= numEvents)
			break;
	}
}

} 

